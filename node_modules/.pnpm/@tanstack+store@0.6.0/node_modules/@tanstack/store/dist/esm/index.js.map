{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * @private\n */\nexport type AnyUpdater = (...args: Array<any>) => any\n\n/**\n * @private\n */\nexport type Listener = () => void\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  /**\n   * Replace the default update function with a custom one.\n   */\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  /**\n   * Called when a listener subscribes to the store.\n   *\n   * @return a function to unsubscribe the listener\n   */\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  /**\n   * Called after the state has been updated, used to derive other state.\n   */\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  /**\n   * @private\n   */\n  _batching = false\n  /**\n   * @private\n   */\n  _flushing = 0\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (updater: TUpdater) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  /**\n   * @private\n   */\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener()\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n"],"names":[],"mappings":"AAiCO,MAAM,MAGX;AAAA,EAaA,YAAY,cAAsB,SAA0C;AAZ5E,SAAA,gCAAgB,IAAc;AAMlB,SAAA,YAAA;AAIA,SAAA,YAAA;AAOZ,SAAA,YAAY,CAAC,aAAuB;AArB/B;AAsBE,WAAA,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,gBAAK,YAAL,mBAAc,gBAAd,4BAA4B,UAAU;AACpD,aAAO,MAAM;AACN,aAAA,UAAU,OAAO,QAAQ;AACtB;AAAA,MACV;AAAA,IACF;AAEA,SAAA,WAAW,CAAC,YAAsB;AA9B7B;AA+BH,YAAM,WAAW,KAAK;AACtB,WAAK,UAAQ,UAAK,YAAL,mBAAc,YACvB,KAAK,QAAQ,SAAS,QAAQ,EAAE,OAAO,IACtC,QAAgB,QAAQ;AAG7B,uBAAK,YAAL,mBAAc,aAAd;AAGA,WAAK,OAAO;AAAA,IACd;AAKA,SAAA,SAAS,MAAM;AACb,UAAI,KAAK,UAAW;AACd,YAAA,UAAU,EAAE,KAAK;AAClB,WAAA,UAAU,QAAQ,CAAC,aAAa;AAC/B,YAAA,KAAK,cAAc,QAAS;AACvB,iBAAA;AAAA,MAAA,CACV;AAAA,IACH;AAEA,SAAA,QAAQ,CAAC,OAAmB;AACtB,UAAA,KAAK,UAAW,QAAO,GAAG;AAC9B,WAAK,YAAY;AACd,SAAA;AACH,WAAK,YAAY;AACjB,WAAK,OAAO;AAAA,IACd;AA5CE,SAAK,QAAQ;AACb,SAAK,UAAU;AAAA,EAAA;AA4CnB;"}