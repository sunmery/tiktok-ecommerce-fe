import path from "node:path";
import * as fs from "node:fs";
import * as fsp from "node:fs/promises";
import * as prettier from "prettier";
import { logging, multiSortBy, replaceBackslash, removeExt, writeIfDifferent, removeUnderscores, removeTrailingSlash, determineInitialRoutePath, trimPathLeft, routePathToVariable } from "./utils.js";
import { getRouteNodes as getRouteNodes$1 } from "./filesystem/physical/getRouteNodes.js";
import { getRouteNodes } from "./filesystem/virtual/getRouteNodes.js";
import { rootPathId } from "./filesystem/physical/rootPathId.js";
const CONSTANTS = {
  // When changing this, you'll want to update the import in `start/api/index.ts#defaultAPIFileRouteHandler`
  APIRouteExportVariable: "APIRoute"
};
let latestTask = 0;
const routeGroupPatternRegex = /\(.+\)/g;
const possiblyNestedRouteGroupPatternRegex = /\([^/]+\)\/?/g;
let isFirst = false;
let skipMessage = false;
async function generator(config) {
  const logger = logging({ disabled: config.disableLogging });
  logger.log("");
  if (!isFirst) {
    logger.log("♻️  Generating routes...");
    isFirst = true;
  } else if (skipMessage) {
    skipMessage = false;
  } else {
    logger.log("♻️  Regenerating routes...");
  }
  const taskId = latestTask + 1;
  latestTask = taskId;
  const checkLatest = () => {
    if (latestTask !== taskId) {
      skipMessage = true;
      return false;
    }
    return true;
  };
  const start = Date.now();
  const TYPES_DISABLED = config.disableTypes;
  const prettierOptions = {
    semi: config.semicolons,
    singleQuote: config.quoteStyle === "single",
    parser: "typescript"
  };
  let getRouteNodesResult;
  if (config.virtualRouteConfig) {
    getRouteNodesResult = await getRouteNodes(config);
  } else {
    getRouteNodesResult = await getRouteNodes$1(config);
  }
  const { rootRouteNode, routeNodes: beforeRouteNodes } = getRouteNodesResult;
  if (rootRouteNode === void 0) {
    let errorMessage = `rootRouteNode must not be undefined. Make sure you've added your root route into the route-tree.`;
    if (!config.virtualRouteConfig) {
      errorMessage += `
Make sure that you add a "${rootPathId}.${config.disableTypes ? "js" : "tsx"}" file to your routes directory.
Add the file in: "${config.routesDirectory}/${rootPathId}.${config.disableTypes ? "js" : "tsx"}"`;
    }
    throw new Error(errorMessage);
  }
  const preRouteNodes = multiSortBy(beforeRouteNodes, [
    (d) => d.routePath === "/" ? -1 : 1,
    (d) => {
      var _a;
      return (_a = d.routePath) == null ? void 0 : _a.split("/").length;
    },
    (d) => d.filePath.match(new RegExp(`[./]${config.indexToken}[.]`)) ? 1 : -1,
    (d) => d.filePath.match(
      /[./](component|errorComponent|pendingComponent|loader|lazy)[.]/
    ) ? 1 : -1,
    (d) => d.filePath.match(new RegExp(`[./]${config.routeToken}[.]`)) ? -1 : 1,
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.endsWith("/")) ? -1 : 1;
    },
    (d) => d.routePath
  ]).filter((d) => ![`/${rootPathId}`].includes(d.routePath || ""));
  const routeTree = [];
  const routePiecesByPath = {};
  const routeNodes = [];
  const handleRootNode = async (node) => {
    if (!node) {
      return;
    }
    const routeCode = fs.readFileSync(node.fullPath, "utf-8");
    if (!routeCode) {
      const replaced = fillTemplate(
        [
          'import * as React from "react"\n',
          "%%tsrImports%%",
          "\n\n",
          "%%tsrExportStart%%{\n component: RootComponent\n }%%tsrExportEnd%%\n\n",
          'function RootComponent() { return (<React.Fragment><div>Hello "%%tsrPath%%"!</div><Outlet /></React.Fragment>) };\n'
        ].join(""),
        {
          tsrImports: "import { Outlet, createRootRoute } from '@tanstack/react-router';",
          tsrPath: rootPathId,
          tsrExportStart: `export const Route = createRootRoute(`,
          tsrExportEnd: ");"
        }
      );
      logger.log(`🟡 Creating ${node.fullPath}`);
      fs.writeFileSync(
        node.fullPath,
        await prettier.format(replaced, prettierOptions)
      );
    }
  };
  await handleRootNode(rootRouteNode);
  const handleNode = async (node) => {
    var _a, _b;
    let parentRoute = hasParentRoute(routeNodes, node, node.routePath);
    if ((parentRoute == null ? void 0 : parentRoute.isVirtualParentRoute) && ((_a = parentRoute.children) == null ? void 0 : _a.length)) {
      const possibleParentRoute = hasParentRoute(
        parentRoute.children,
        node,
        node.routePath
      );
      if (possibleParentRoute) {
        parentRoute = possibleParentRoute;
      }
    }
    if (parentRoute) node.parent = parentRoute;
    node.path = determineNodePath(node);
    const trimmedPath = trimPathLeft(node.path ?? "");
    const split = trimmedPath.split("/");
    const lastRouteSegment = split[split.length - 1] ?? trimmedPath;
    node.isNonPath = lastRouteSegment.startsWith("_") || routeGroupPatternRegex.test(lastRouteSegment);
    node.cleanedPath = removeGroups(
      removeUnderscores(removeLayoutSegments(node.path)) ?? ""
    );
    if (!node.isVirtualParentRoute && !node.isVirtual) {
      const routeCode = fs.readFileSync(node.fullPath, "utf-8");
      const escapedRoutePath = ((_b = node.routePath) == null ? void 0 : _b.replaceAll("$", "$$")) ?? "";
      let replaced = routeCode;
      if (!routeCode) {
        if (node.isLazy) {
          replaced = fillTemplate(config.customScaffolding.routeTemplate, {
            tsrImports: "import { createLazyFileRoute } from '@tanstack/react-router';",
            tsrPath: escapedRoutePath,
            tsrExportStart: `export const Route = createLazyFileRoute('${escapedRoutePath}')(`,
            tsrExportEnd: ");"
          });
        } else if (node.isRoute || !node.isComponent && !node.isErrorComponent && !node.isPendingComponent && !node.isLoader) {
          replaced = fillTemplate(config.customScaffolding.routeTemplate, {
            tsrImports: "import { createFileRoute } from '@tanstack/react-router';",
            tsrPath: escapedRoutePath,
            tsrExportStart: `export const Route = createFileRoute('${escapedRoutePath}')(`,
            tsrExportEnd: ");"
          });
        }
      } else {
        replaced = routeCode.replace(
          /(FileRoute\(\s*['"])([^\s]*)(['"],?\s*\))/g,
          (_, p1, __, p3) => `${p1}${escapedRoutePath}${p3}`
        ).replace(
          /(import\s*\{.*)(create(Lazy)?FileRoute)(.*\}\s*from\s*['"]@tanstack\/react-router['"])/gs,
          (_, p1, __, ___, p4) => `${p1}${node.isLazy ? "createLazyFileRoute" : "createFileRoute"}${p4}`
        ).replace(
          /create(Lazy)?FileRoute(\(\s*['"])([^\s]*)(['"],?\s*\))/g,
          (_, __, p2, ___, p4) => `${node.isLazy ? "createLazyFileRoute" : "createFileRoute"}${p2}${escapedRoutePath}${p4}`
        );
      }
      await writeIfDifferent(
        node.fullPath,
        prettierOptions,
        routeCode,
        replaced,
        {
          beforeWrite: () => {
            logger.log(`🟡 Updating ${node.fullPath}`);
          }
        }
      );
    }
    if (!node.isVirtual && (node.isLoader || node.isComponent || node.isErrorComponent || node.isPendingComponent || node.isLazy)) {
      routePiecesByPath[node.routePath] = routePiecesByPath[node.routePath] || {};
      routePiecesByPath[node.routePath][node.isLazy ? "lazy" : node.isLoader ? "loader" : node.isErrorComponent ? "errorComponent" : node.isPendingComponent ? "pendingComponent" : "component"] = node;
      const anchorRoute = routeNodes.find((d) => d.routePath === node.routePath);
      if (!anchorRoute) {
        await handleNode({
          ...node,
          isVirtual: true,
          isLazy: false,
          isLoader: false,
          isComponent: false,
          isErrorComponent: false,
          isPendingComponent: false
        });
      }
      return;
    }
    const cleanedPathIsEmpty = (node.cleanedPath || "").length === 0;
    const nonPathRoute = node.isRoute && node.isNonPath;
    node.isVirtualParentRequired = node.isLayout || nonPathRoute ? !cleanedPathIsEmpty : false;
    if (!node.isVirtual && node.isVirtualParentRequired) {
      const parentRoutePath = removeLastSegmentFromPath(node.routePath) || "/";
      const parentVariableName = routePathToVariable(parentRoutePath);
      const anchorRoute = routeNodes.find(
        (d) => d.routePath === parentRoutePath
      );
      if (!anchorRoute) {
        const parentNode = {
          ...node,
          path: removeLastSegmentFromPath(node.path) || "/",
          filePath: removeLastSegmentFromPath(node.filePath) || "/",
          fullPath: removeLastSegmentFromPath(node.fullPath) || "/",
          routePath: parentRoutePath,
          variableName: parentVariableName,
          isVirtual: true,
          isLayout: false,
          isVirtualParentRoute: true,
          isVirtualParentRequired: false
        };
        parentNode.children = parentNode.children ?? [];
        parentNode.children.push(node);
        node.parent = parentNode;
        if (node.isLayout) {
          node.path = determineNodePath(node);
        }
        await handleNode(parentNode);
      } else {
        anchorRoute.children = anchorRoute.children ?? [];
        anchorRoute.children.push(node);
        node.parent = anchorRoute;
      }
    }
    if (node.parent) {
      if (!node.isVirtualParentRequired) {
        node.parent.children = node.parent.children ?? [];
        node.parent.children.push(node);
      }
    } else {
      routeTree.push(node);
    }
    routeNodes.push(node);
  };
  for (const node of preRouteNodes.filter((d) => !d.isAPIRoute)) {
    await handleNode(node);
  }
  checkRouteFullPathUniqueness(
    preRouteNodes.filter(
      (d) => !d.isAPIRoute && d.children === void 0 && d.isLazy !== true
    ),
    config
  );
  const startAPIRouteNodes = checkStartAPIRoutes(
    preRouteNodes.filter((d) => d.isAPIRoute),
    config
  );
  const handleAPINode = async (node) => {
    var _a;
    const routeCode = fs.readFileSync(node.fullPath, "utf-8");
    const escapedRoutePath = ((_a = node.routePath) == null ? void 0 : _a.replaceAll("$", "$$")) ?? "";
    if (!routeCode) {
      const replaced = fillTemplate(config.customScaffolding.apiTemplate, {
        tsrImports: "import { createAPIFileRoute } from '@tanstack/start/api';",
        tsrPath: escapedRoutePath,
        tsrExportStart: `export const ${CONSTANTS.APIRouteExportVariable} = createAPIFileRoute('${escapedRoutePath}')(`,
        tsrExportEnd: ");"
      });
      logger.log(`🟡 Creating ${node.fullPath}`);
      fs.writeFileSync(
        node.fullPath,
        await prettier.format(replaced, prettierOptions)
      );
    } else {
      await writeIfDifferent(
        node.fullPath,
        prettierOptions,
        routeCode,
        routeCode.replace(
          /(createAPIFileRoute\(\s*['"])([^\s]*)(['"],?\s*\))/g,
          (_, p1, __, p3) => `${p1}${escapedRoutePath}${p3}`
        ),
        {
          beforeWrite: () => {
            logger.log(`🟡 Updating ${node.fullPath}`);
          }
        }
      );
    }
  };
  for (const node of startAPIRouteNodes) {
    await handleAPINode(node);
  }
  function buildRouteTreeConfig(nodes, depth = 1) {
    const children = nodes.map((node) => {
      var _a, _b;
      if (node.isRoot) {
        return;
      }
      if (node.isLayout && !((_a = node.children) == null ? void 0 : _a.length)) {
        return;
      }
      const route = `${node.variableName}Route`;
      if ((_b = node.children) == null ? void 0 : _b.length) {
        const childConfigs = buildRouteTreeConfig(node.children, depth + 1);
        const childrenDeclaration = TYPES_DISABLED ? "" : `interface ${route}Children {
  ${node.children.map((child) => `${child.variableName}Route: typeof ${getResolvedRouteNodeVariableName(child)}`).join(",")}
}`;
        const children2 = `const ${route}Children${TYPES_DISABLED ? "" : `: ${route}Children`} = {
  ${node.children.map((child) => `${child.variableName}Route: ${getResolvedRouteNodeVariableName(child)}`).join(",")}
}`;
        const routeWithChildren = `const ${route}WithChildren = ${route}._addFileChildren(${route}Children)`;
        return [
          childConfigs,
          childrenDeclaration,
          children2,
          routeWithChildren
        ].join("\n\n");
      }
      return void 0;
    });
    return children.filter(Boolean).join("\n\n");
  }
  const routeConfigChildrenText = buildRouteTreeConfig(routeTree);
  const sortedRouteNodes = multiSortBy(routeNodes, [
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.includes(`/${rootPathId}`)) ? -1 : 1;
    },
    (d) => {
      var _a;
      return (_a = d.routePath) == null ? void 0 : _a.split("/").length;
    },
    (d) => {
      var _a;
      return ((_a = d.routePath) == null ? void 0 : _a.endsWith(config.indexToken)) ? -1 : 1;
    },
    (d) => d
  ]);
  const imports = Object.entries({
    createFileRoute: sortedRouteNodes.some((d) => d.isVirtual),
    lazyFn: sortedRouteNodes.some(
      (node) => {
        var _a;
        return (_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.loader;
      }
    ),
    lazyRouteComponent: sortedRouteNodes.some(
      (node) => {
        var _a, _b, _c;
        return ((_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.component) || ((_b = routePiecesByPath[node.routePath]) == null ? void 0 : _b.errorComponent) || ((_c = routePiecesByPath[node.routePath]) == null ? void 0 : _c.pendingComponent);
      }
    )
  }).filter((d) => d[1]).map((d) => d[0]);
  const virtualRouteNodes = sortedRouteNodes.filter((d) => d.isVirtual);
  function getImportPath(node) {
    return replaceBackslash(
      removeExt(
        path.relative(
          path.dirname(config.generatedRouteTree),
          path.resolve(config.routesDirectory, node.filePath)
        ),
        config.addExtensions
      )
    );
  }
  const routeImports = [
    ...config.routeTreeFileHeader,
    `// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.`,
    imports.length ? `import { ${imports.join(", ")} } from '@tanstack/react-router'
` : "",
    "// Import Routes",
    [
      `import { Route as rootRoute } from './${getImportPath(rootRouteNode)}'`,
      ...sortedRouteNodes.filter((d) => !d.isVirtual).map((node) => {
        return `import { Route as ${node.variableName}Import } from './${getImportPath(node)}'`;
      })
    ].join("\n"),
    virtualRouteNodes.length ? "// Create Virtual Routes" : "",
    virtualRouteNodes.map((node) => {
      return `const ${node.variableName}Import = createFileRoute('${node.routePath}')()`;
    }).join("\n"),
    "// Create/Update Routes",
    sortedRouteNodes.map((node) => {
      var _a, _b, _c, _d, _e, _f;
      const loaderNode = (_a = routePiecesByPath[node.routePath]) == null ? void 0 : _a.loader;
      const componentNode = (_b = routePiecesByPath[node.routePath]) == null ? void 0 : _b.component;
      const errorComponentNode = (_c = routePiecesByPath[node.routePath]) == null ? void 0 : _c.errorComponent;
      const pendingComponentNode = (_d = routePiecesByPath[node.routePath]) == null ? void 0 : _d.pendingComponent;
      const lazyComponentNode = (_e = routePiecesByPath[node.routePath]) == null ? void 0 : _e.lazy;
      return [
        `const ${node.variableName}Route = ${node.variableName}Import.update({
          ${[
          `id: '${node.path}'`,
          !node.isNonPath ? `path: '${node.cleanedPath}'` : void 0,
          `getParentRoute: () => ${((_f = node.parent) == null ? void 0 : _f.variableName) ?? "root"}Route`
        ].filter(Boolean).join(",")}
        }${TYPES_DISABLED ? "" : "as any"})`,
        loaderNode ? `.updateLoader({ loader: lazyFn(() => import('./${replaceBackslash(
          removeExt(
            path.relative(
              path.dirname(config.generatedRouteTree),
              path.resolve(config.routesDirectory, loaderNode.filePath)
            ),
            config.addExtensions
          )
        )}'), 'loader') })` : "",
        componentNode || errorComponentNode || pendingComponentNode ? `.update({
              ${[
          ["component", componentNode],
          ["errorComponent", errorComponentNode],
          ["pendingComponent", pendingComponentNode]
        ].filter((d) => d[1]).map((d) => {
          return `${d[0]}: lazyRouteComponent(() => import('./${replaceBackslash(
            removeExt(
              path.relative(
                path.dirname(config.generatedRouteTree),
                path.resolve(config.routesDirectory, d[1].filePath)
              ),
              config.addExtensions
            )
          )}'), '${d[0]}')`;
        }).join("\n,")}
            })` : "",
        lazyComponentNode ? `.lazy(() => import('./${replaceBackslash(
          removeExt(
            path.relative(
              path.dirname(config.generatedRouteTree),
              path.resolve(
                config.routesDirectory,
                lazyComponentNode.filePath
              )
            ),
            config.addExtensions
          )
        )}').then((d) => d.Route))` : ""
      ].join("");
    }).join("\n\n"),
    ...TYPES_DISABLED ? [] : [
      "// Populate the FileRoutesByPath interface",
      `declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    ${routeNodes.map((routeNode) => {
        var _a, _b;
        const filePathId = routeNode.routePath;
        return `'${filePathId}': {
          id: '${filePathId}'
          path: '${inferPath(routeNode)}'
          fullPath: '${inferFullPath(routeNode)}'
          preLoaderRoute: typeof ${routeNode.variableName}Import
          parentRoute: typeof ${routeNode.isVirtualParentRequired ? `${(_a = routeNode.parent) == null ? void 0 : _a.variableName}Route` : ((_b = routeNode.parent) == null ? void 0 : _b.variableName) ? `${routeNode.parent.variableName}Import` : "rootRoute"}
        }`;
      }).join("\n")}
  }
}`
    ],
    "// Create and export the route tree",
    routeConfigChildrenText,
    ...TYPES_DISABLED ? [] : [
      `export interface FileRoutesByFullPath {
  ${[...createRouteNodesByFullPath(routeNodes).entries()].map(
        ([fullPath, routeNode]) => {
          return `'${fullPath}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`;
        }
      )}
}`,
      `export interface FileRoutesByTo {
  ${[...createRouteNodesByTo(routeNodes).entries()].map(([to, routeNode]) => {
        return `'${to}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`;
      })}
}`,
      `export interface FileRoutesById {
  '__root__': typeof rootRoute,
  ${[...createRouteNodesById(routeNodes).entries()].map(([id, routeNode]) => {
        return `'${id}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`;
      })}
}`,
      `export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: ${routeNodes.length > 0 ? [...createRouteNodesByFullPath(routeNodes).keys()].map((fullPath) => `'${fullPath}'`).join("|") : "never"}
  fileRoutesByTo: FileRoutesByTo
  to: ${routeNodes.length > 0 ? [...createRouteNodesByTo(routeNodes).keys()].map((to) => `'${to}'`).join("|") : "never"}
  id: ${[`'__root__'`, ...[...createRouteNodesById(routeNodes).keys()].map((id) => `'${id}'`)].join("|")}
  fileRoutesById: FileRoutesById
}`,
      `export interface RootRouteChildren {
  ${routeTree.map((child) => `${child.variableName}Route: typeof ${getResolvedRouteNodeVariableName(child)}`).join(",")}
}`
    ],
    `const rootRouteChildren${TYPES_DISABLED ? "" : ": RootRouteChildren"} = {
  ${routeTree.map((child) => `${child.variableName}Route: ${getResolvedRouteNodeVariableName(child)}`).join(",")}
}`,
    `export const routeTree = rootRoute._addFileChildren(rootRouteChildren)${TYPES_DISABLED ? "" : "._addFileTypes<FileRouteTypes>()"}`,
    ...config.routeTreeFileFooter
  ].filter(Boolean).join("\n\n");
  const createRouteManifest = () => {
    const routesManifest = {
      __root__: {
        filePath: rootRouteNode.filePath,
        children: routeTree.map((d) => d.routePath)
      },
      ...Object.fromEntries(
        routeNodes.map((d) => {
          var _a, _b;
          const filePathId = d.routePath;
          return [
            filePathId,
            {
              filePath: d.filePath,
              parent: ((_a = d.parent) == null ? void 0 : _a.routePath) ? d.parent.routePath : void 0,
              children: (_b = d.children) == null ? void 0 : _b.map((childRoute) => childRoute.routePath)
            }
          ];
        })
      )
    };
    return JSON.stringify(
      {
        routes: routesManifest
      },
      null,
      2
    );
  };
  const routeConfigFileContent = config.disableManifestGeneration ? routeImports : [
    routeImports,
    "\n",
    "/* ROUTE_MANIFEST_START",
    createRouteManifest(),
    "ROUTE_MANIFEST_END */"
  ].join("\n");
  if (!checkLatest()) return;
  const existingRouteTreeContent = await fsp.readFile(path.resolve(config.generatedRouteTree), "utf-8").catch((err) => {
    if (err.code === "ENOENT") {
      return "";
    }
    throw err;
  });
  if (!checkLatest()) return;
  await fsp.mkdir(path.dirname(path.resolve(config.generatedRouteTree)), {
    recursive: true
  });
  if (!checkLatest()) return;
  const routeTreeWriteResult = await writeIfDifferent(
    path.resolve(config.generatedRouteTree),
    prettierOptions,
    existingRouteTreeContent,
    routeConfigFileContent,
    {
      beforeWrite: () => {
        logger.log(`🟡 Updating ${config.generatedRouteTree}`);
      }
    }
  );
  if (routeTreeWriteResult && !checkLatest()) {
    return;
  }
  logger.log(
    `✅ Processed ${routeNodes.length === 1 ? "route" : "routes"} in ${Date.now() - start}ms`
  );
}
function removeGroups(s) {
  return s.replace(possiblyNestedRouteGroupPatternRegex, "");
}
function determineNodePath(node) {
  var _a;
  return node.path = node.parent ? ((_a = node.routePath) == null ? void 0 : _a.replace(node.parent.routePath ?? "", "")) || "/" : node.routePath;
}
function removeLastSegmentFromPath(routePath = "/") {
  const segments = routePath.split("/");
  segments.pop();
  return segments.join("/");
}
function removeLayoutSegments(routePath = "/") {
  const segments = routePath.split("/");
  const newSegments = segments.filter((segment) => !segment.startsWith("_"));
  return newSegments.join("/");
}
function hasParentRoute(routes, node, routePathToCheck) {
  if (!routePathToCheck || routePathToCheck === "/") {
    return null;
  }
  const sortedNodes = multiSortBy(routes, [
    (d) => d.routePath.length * -1,
    (d) => d.variableName
  ]).filter((d) => d.routePath !== `/${rootPathId}`);
  for (const route of sortedNodes) {
    if (route.routePath === "/") continue;
    if (routePathToCheck.startsWith(`${route.routePath}/`) && route.routePath !== routePathToCheck) {
      return route;
    }
  }
  const segments = routePathToCheck.split("/");
  segments.pop();
  const parentRoutePath = segments.join("/");
  return hasParentRoute(routes, node, parentRoutePath);
}
const getResolvedRouteNodeVariableName = (routeNode) => {
  var _a;
  return ((_a = routeNode.children) == null ? void 0 : _a.length) ? `${routeNode.variableName}RouteWithChildren` : `${routeNode.variableName}Route`;
};
const createRouteNodesByFullPath = (routeNodes) => {
  return new Map(
    routeNodes.map((routeNode) => [inferFullPath(routeNode), routeNode])
  );
};
const createRouteNodesByTo = (routeNodes) => {
  return new Map(
    dedupeBranchesAndIndexRoutes(routeNodes).map((routeNode) => [
      inferTo(routeNode),
      routeNode
    ])
  );
};
const createRouteNodesById = (routeNodes) => {
  return new Map(
    routeNodes.map((routeNode) => {
      const id = routeNode.routePath ?? "";
      return [id, routeNode];
    })
  );
};
const inferFullPath = (routeNode) => {
  const fullPath = removeGroups(
    removeUnderscores(removeLayoutSegments(routeNode.routePath)) ?? ""
  );
  return routeNode.cleanedPath === "/" ? fullPath : fullPath.replace(/\/$/, "");
};
const inferPath = (routeNode) => {
  var _a;
  return routeNode.cleanedPath === "/" ? routeNode.cleanedPath : ((_a = routeNode.cleanedPath) == null ? void 0 : _a.replace(/\/$/, "")) ?? "";
};
const inferTo = (routeNode) => {
  const fullPath = inferFullPath(routeNode);
  if (fullPath === "/") return fullPath;
  return fullPath.replace(/\/$/, "");
};
const dedupeBranchesAndIndexRoutes = (routes) => {
  return routes.filter((route) => {
    var _a;
    if ((_a = route.children) == null ? void 0 : _a.find((child) => child.cleanedPath === "/")) return false;
    return true;
  });
};
function checkUnique(routes, key) {
  const keys = routes.map((d) => d[key]);
  const uniqueKeys = new Set(keys);
  if (keys.length !== uniqueKeys.size) {
    const duplicateKeys = keys.filter((d, i) => keys.indexOf(d) !== i);
    const conflictingFiles = routes.filter(
      (d) => duplicateKeys.includes(d[key])
    );
    return conflictingFiles;
  }
  return void 0;
}
function checkRouteFullPathUniqueness(_routes, config) {
  const routes = _routes.map((d) => {
    const inferredFullPath = inferFullPath(d);
    return { ...d, inferredFullPath };
  });
  const conflictingFiles = checkUnique(routes, "inferredFullPath");
  if (conflictingFiles !== void 0) {
    const errorMessage = `Conflicting configuration paths were found for the following route${conflictingFiles.length > 1 ? "s" : ""}: ${conflictingFiles.map((p) => `"${p.inferredFullPath}"`).join(", ")}.
Please ensure each route has a unique full path.
Conflicting files: 
 ${conflictingFiles.map((d) => path.resolve(config.routesDirectory, d.filePath)).join("\n ")}
`;
    throw new Error(errorMessage);
  }
}
function checkStartAPIRoutes(_routes, config) {
  if (_routes.length === 0) {
    return [];
  }
  const routes = _routes.map((d) => {
    const routePath = removeTrailingSlash(d.routePath ?? "");
    return { ...d, routePath };
  });
  const conflictingFiles = checkUnique(routes, "routePath");
  if (conflictingFiles !== void 0) {
    const errorMessage = `Conflicting configuration paths were found for the following API route${conflictingFiles.length > 1 ? "s" : ""}: ${conflictingFiles.map((p) => `"${p}"`).join(", ")}.
  Please ensure each API route has a unique route path.
Conflicting files: 
 ${conflictingFiles.map((d) => path.resolve(config.routesDirectory, d.filePath)).join("\n ")}
`;
    throw new Error(errorMessage);
  }
  return routes;
}
function startAPIRouteSegmentsFromTSRFilePath(src, config) {
  const routePath = determineInitialRoutePath(src);
  const parts = routePath.replaceAll(".", "/").split("/").filter((p) => !!p && p !== config.indexToken);
  const segments = parts.map((part) => {
    if (part.startsWith("$")) {
      if (part === "$") {
        return { value: part, type: "splat" };
      }
      part.replaceAll("$", "");
      return { value: part, type: "param" };
    }
    return { value: part, type: "path" };
  });
  return segments;
}
function fillTemplate(template, values) {
  return template.replace(
    /%%(\w+)%%/g,
    (_, key) => values[key] || ""
  );
}
export {
  CONSTANTS,
  createRouteNodesByFullPath,
  createRouteNodesById,
  createRouteNodesByTo,
  dedupeBranchesAndIndexRoutes,
  generator,
  getResolvedRouteNodeVariableName,
  hasParentRoute,
  inferFullPath,
  inferPath,
  inferTo,
  removeLastSegmentFromPath,
  startAPIRouteSegmentsFromTSRFilePath
};
//# sourceMappingURL=generator.js.map
