import path, { resolve, join } from "node:path";
import { routePathToVariable, removeExt, removeTrailingSlash, removeLeadingSlash } from "../../utils.js";
import { getRouteNodes as getRouteNodes$1 } from "../physical/getRouteNodes.js";
function ensureLeadingUnderScore(id) {
  if (id.startsWith("_")) {
    return id;
  }
  return `_${id}`;
}
function flattenTree(node) {
  const result = [node];
  if (node.children) {
    for (const child of node.children) {
      result.push(...flattenTree(child));
    }
  }
  delete node.children;
  return result;
}
async function getRouteNodes(tsrConfig) {
  const fullDir = resolve(tsrConfig.routesDirectory);
  if (tsrConfig.virtualRouteConfig === void 0) {
    throw new Error(`virtualRouteConfig is undefined`);
  }
  const children = await getRouteNodesRecursive(
    tsrConfig,
    fullDir,
    tsrConfig.virtualRouteConfig.children
  );
  const allNodes = flattenTree({
    children,
    filePath: tsrConfig.virtualRouteConfig.file,
    fullPath: join(fullDir, tsrConfig.virtualRouteConfig.file),
    variableName: "rootRoute",
    routePath: "/",
    isRoot: true
  });
  const rootRouteNode = allNodes[0];
  const routeNodes = allNodes.slice(1);
  return { rootRouteNode, routeNodes };
}
async function getRouteNodesRecursive(tsrConfig, fullDir, nodes, parent) {
  if (nodes === void 0) {
    return [];
  }
  const children = await Promise.all(
    nodes.map(async (node) => {
      if (node.type === "physical") {
        const { routeNodes } = await getRouteNodes$1({
          ...tsrConfig,
          routesDirectory: resolve(fullDir, node.directory)
        });
        routeNodes.forEach((subtreeNode) => {
          subtreeNode.variableName = routePathToVariable(
            `${node.pathPrefix}/${removeExt(subtreeNode.filePath)}`
          );
          subtreeNode.routePath = `${(parent == null ? void 0 : parent.routePath) ?? ""}${node.pathPrefix}${subtreeNode.routePath}`;
          subtreeNode.filePath = `${node.directory}/${subtreeNode.filePath}`;
        });
        return routeNodes;
      }
      function getFile(file) {
        const filePath = file;
        const variableName = routePathToVariable(removeExt(filePath));
        const fullPath = join(fullDir, filePath);
        return { filePath, variableName, fullPath };
      }
      const parentRoutePath = removeTrailingSlash((parent == null ? void 0 : parent.routePath) ?? "/");
      const isLayout = node.type === "layout";
      switch (node.type) {
        case "index": {
          const { filePath, variableName, fullPath } = getFile(node.file);
          const routePath = `${parentRoutePath}/`;
          return {
            filePath,
            fullPath,
            variableName,
            routePath,
            isLayout
          };
        }
        case "route": {
          const lastSegment = node.path;
          let routeNode;
          const routePath = `${parentRoutePath}/${removeLeadingSlash(lastSegment)}`;
          if (node.file) {
            const { filePath, variableName, fullPath } = getFile(node.file);
            routeNode = {
              filePath,
              fullPath,
              variableName,
              routePath,
              isLayout
            };
          } else {
            routeNode = {
              filePath: "",
              fullPath: "",
              variableName: routePathToVariable(routePath),
              routePath,
              isLayout,
              isVirtual: true
            };
          }
          if (node.children !== void 0) {
            const children2 = await getRouteNodesRecursive(
              tsrConfig,
              fullDir,
              node.children,
              routeNode
            );
            routeNode.children = children2;
          }
          return routeNode;
        }
        case "layout": {
          const { filePath, variableName, fullPath } = getFile(node.file);
          if (node.id !== void 0) {
            node.id = ensureLeadingUnderScore(node.id);
          } else {
            const baseName = path.basename(filePath);
            const fileNameWithoutExt = path.parse(baseName).name;
            node.id = ensureLeadingUnderScore(fileNameWithoutExt);
          }
          const lastSegment = node.id;
          const routePath = `${parentRoutePath}/${removeLeadingSlash(lastSegment)}`;
          const routeNode = {
            fullPath,
            isLayout,
            filePath,
            variableName,
            routePath
          };
          if (node.children !== void 0) {
            const children2 = await getRouteNodesRecursive(
              tsrConfig,
              fullDir,
              node.children,
              routeNode
            );
            routeNode.children = children2;
          }
          return routeNode;
        }
      }
    })
  );
  return children.flat();
}
export {
  getRouteNodes,
  getRouteNodesRecursive
};
//# sourceMappingURL=getRouteNodes.js.map
