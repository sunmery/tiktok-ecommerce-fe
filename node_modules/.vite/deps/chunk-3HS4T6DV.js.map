{
  "version": 3,
  "sources": ["../../.pnpm/valtio@2.1.2_@types+react@18.3.10_react@18.3.1/node_modules/valtio/esm/react.mjs", "../../.pnpm/proxy-compare@3.0.0/node_modules/proxy-compare/dist/index.js", "../../.pnpm/valtio@2.1.2_@types+react@18.3.10_react@18.3.1/node_modules/valtio/esm/vanilla.mjs"],
  "sourcesContent": ["import { useMemo, useRef, useSyncExternalStore, useCallback, useLayoutEffect, useEffect, useDebugValue } from 'react';\nimport { isChanged, createProxy, affectedToPathList } from 'proxy-compare';\nimport { subscribe, snapshot } from 'valtio/vanilla';\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected, true);\n  });\n  useDebugValue(pathList.current);\n};\nconst condUseAffectedDebugValue = useAffectedDebugValue;\nconst targetCache = /* @__PURE__ */ new WeakMap();\nfunction useSnapshot(proxyObject, options) {\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const affected = useMemo(\n    () => proxyObject && /* @__PURE__ */ new WeakMap(),\n    [proxyObject]\n  );\n  const lastSnapshot = useRef();\n  let inRender = true;\n  const currSnapshot = useSyncExternalStore(\n    useCallback(\n      (callback) => {\n        const unsub = subscribe(proxyObject, callback, notifyInSync);\n        callback();\n        return unsub;\n      },\n      [proxyObject, notifyInSync]\n    ),\n    () => {\n      const nextSnapshot = snapshot(proxyObject);\n      try {\n        if (!inRender && lastSnapshot.current && !isChanged(\n          lastSnapshot.current,\n          nextSnapshot,\n          affected,\n          /* @__PURE__ */ new WeakMap()\n        )) {\n          return lastSnapshot.current;\n        }\n      } catch (e) {\n      }\n      return nextSnapshot;\n    },\n    () => snapshot(proxyObject)\n  );\n  inRender = false;\n  useLayoutEffect(() => {\n    lastSnapshot.current = currSnapshot;\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    condUseAffectedDebugValue(currSnapshot, affected);\n  }\n  const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);\n  return createProxy(currSnapshot, affected, proxyCache, targetCache);\n}\n\nexport { useSnapshot };\n", "/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nexport const isChanged = (prevObj, nextObj, affected, cache, isEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n            return hit[CHANGED_PROPERTY];\n        }\n        // for object with cycles\n        cache.set(prevObj, {\n            [NEXT_OBJECT_PROPERTY]: nextObj,\n            [CHANGED_PROPERTY]: false,\n        });\n    }\n    let changed = null;\n    try {\n        for (const key of used[HAS_KEY_PROPERTY] || []) {\n            changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n            if (changed)\n                return changed;\n        }\n        if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n            changed = isAllOwnKeysChanged(prevObj, nextObj);\n            if (changed)\n                return changed;\n        }\n        else {\n            for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n                const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n                const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n                changed = hasPrev !== hasNext;\n                if (changed)\n                    return changed;\n            }\n        }\n        for (const key of used[KEYS_PROPERTY] || []) {\n            changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n            if (changed)\n                return changed;\n        }\n        if (changed === null)\n            changed = true;\n        return changed;\n    }\n    finally {\n        if (cache) {\n            cache.set(prevObj, {\n                [NEXT_OBJECT_PROPERTY]: nextObj,\n                [CHANGED_PROPERTY]: changed,\n            });\n        }\n    }\n};\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n", "import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nconst createSnapshotDefault = (target, version) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const { enumerable } = Reflect.getOwnPropertyDescriptor(\n      target,\n      key\n    );\n    const desc = {\n      value,\n      enumerable,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshotDefault(target2, ensureVersion());\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n};\nconst createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({\n  deleteProperty(target, prop) {\n    const prevValue = Reflect.get(target, prop);\n    removePropListener(prop);\n    const deleted = Reflect.deleteProperty(target, prop);\n    if (deleted) {\n      notifyUpdate([\"delete\", [prop], prevValue]);\n    }\n    return deleted;\n  },\n  set(target, prop, value, receiver) {\n    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);\n    const prevValue = Reflect.get(target, prop, receiver);\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return true;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = getUntracked(value) || value;\n    }\n    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;\n    addPropListener(prop, nextValue);\n    Reflect.set(target, prop, nextValue, receiver);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n    return true;\n  }\n});\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst snapCache = /* @__PURE__ */ new WeakMap();\nconst versionHolder = [1, 1];\nconst proxyCache = /* @__PURE__ */ new WeakMap();\nlet objectIs = Object.is;\nlet newProxy = (target, handler) => new Proxy(target, handler);\nlet canProxy = canProxyDefault;\nlet createSnapshot = createSnapshotDefault;\nlet createHandler = createHandlerDefault;\nfunction proxy(baseObject = {}) {\n  if (!isObject(baseObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(baseObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propValue) => {\n    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);\n    if (propProxyState) {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  let initializing = true;\n  const handler = createHandler(\n    () => initializing,\n    addPropListener,\n    removePropListener,\n    notifyUpdate\n  );\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(baseObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(baseObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      baseObject,\n      key\n    );\n    if (\"value\" in desc && desc.writable) {\n      proxyObject[key] = baseObject[key];\n    }\n  });\n  initializing = false;\n  return proxyObject;\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[2];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_getInternalStates = () => ({\n  proxyStateMap,\n  refSet,\n  snapCache,\n  versionHolder,\n  proxyCache\n});\nfunction unstable_replaceInternalFunction(name, fn) {\n  switch (name) {\n    case \"objectIs\":\n      objectIs = fn(objectIs);\n      break;\n    case \"newProxy\":\n      newProxy = fn(newProxy);\n      break;\n    case \"canProxy\":\n      canProxy = fn(canProxy);\n      break;\n    case \"createSnapshot\":\n      createSnapshot = fn(createSnapshot);\n      break;\n    case \"createHandler\":\n      createHandler = fn(createHandler);\n      break;\n    default:\n      throw new Error(\"unknown function\");\n  }\n}\n\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_getInternalStates, unstable_replaceInternalFunction };\n"],
  "mappings": "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",
  "names": ["proxyCache", "targetCache", "target", "isObject", "newProxy", "proxyCache"]
}
